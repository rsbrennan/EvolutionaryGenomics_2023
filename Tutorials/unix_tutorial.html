<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />



<meta name="date" content="2023-03-20" />

<title>Unix_tutorial</title>

<script src="site_libs/header-attrs-2.13/header-attrs.js"></script>
<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/bootstrap.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>









<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
details > summary > p:only-child {
  display: inline;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.tab('show');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->




</head>

<body>


<div class="container-fluid main-container">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-bs-toggle="collapse" data-target="#navbar" data-bs-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">bioc 202</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">Home</a>
</li>
<li>
  <a href="schedule.html">Schedule</a>
</li>
<li>
  <a href="syllabus.html">Syllabus</a>
</li>
<li>
  <a href="exercises.html">Exercises</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">



<h1 class="title toc-ignore">Unix_tutorial</h1>
<h4 class="date">2023-03-20</h4>

</div>


<div id="command-line-bootcamp" class="section level1">
<h1>Command-line Bootcamp</h1>
<p><br><br><br></p>
<div id="introduction-introduction" class="section level2">
<h2>Introduction [Introduction]</h2>
<p>This tutorial is from Keith Bradnam, and modified here to fit our
file structure and cloudlab. See the original at: <a
href="https://github.com/KorfLab/unix_and_perl"
class="uri">https://github.com/KorfLab/unix_and_perl</a> . The original
version is licensed under <a
href="http://creativecommons.org/licenses/by/4.0/">CC 4.0</a>. I have
made small changes so that the output shown is what you’ll see in
cloudlab, but the bulk and the actual hard work is original from the
prior source.</p>
<p>This ‘bootcamp’ is intended to provide the reader with a basic
overview of essential Unix/Linux commands that will allow them to
navigate a file system and move, copy, edit files. It will also
introduce a brief overview of some ‘power’ commands in Unix. It was
orginally developed as part of a <a
href="http://bioinformatics.ucdavis.edu">Bioinformatics Core</a>
Workshop taught at UC Davis (<a
href="http://training.bioinformatics.ucdavis.edu/docs/2015/06/june-2015-workshop/index.html">Using
the Linux Command-Line for Analysis of High Throughput Sequence
Data</a>).</p>
</div>
<div id="why-unix-why-unix" class="section level2">
<h2>Why Unix? [Why Unix]</h2>
<p>The <a href="http://en.wikipedia.org/wiki/Unix">Unix operating
system</a> has been around since 1969. Back then there was no such thing
as a graphical user interface. You typed everything. It may seem archaic
to use a keyboard to issue commands today, but it’s much easier to
automate keyboard tasks than mouse tasks. There are several variants of
Unix (including <a href="http://en.wikipedia.org/wiki/Linux">Linux</a>),
though the differences do not matter much for most basic functions.</p>
<p>Increasingly, the raw output of biological research exists as <em>in
silico</em> data, usually in the form of large text files. Unix is
particularly suited to working with such files and has several powerful
(and flexible) commands that can process your data for you. The real
strength of learning Unix is that most of these commands can be combined
in an almost unlimited fashion. So if you can learn just five Unix
commands, you will be able to do a lot more than just five things.</p>
</div>
<div id="typeset-conventions-typeset" class="section level2">
<h2>Typeset Conventions [Typeset]</h2>
<p>Command-line examples that you are meant to type into a terminal
window will be shown indented in a constant-width font, e.g. </p>
<pre><code>ls -lrh</code></pre>
<p>Sometimes the accompanying text will include a reference to a Unix
command. Any such text will also be in a constant-width, boxed font.
E.g.</p>
<blockquote>
<p>Type the <code>pwd</code> command again.</p>
</blockquote>
<p>From time to time this documentation will contain <a
href="http://en.wikipedia.org/wiki/Hyperlink">web links</a> to pages
that will help you find out more about certain Unix commands. Usually,
the <em>first</em> mention of a command or function will be a hyperlink
to Wikipedia.</p>
<p>Important or critical points will be styled like so:</p>
<blockquote>
<p><strong><em>This is an important point!</em></strong></p>
</blockquote>
<hr />
</div>
<div id="assumptions" class="section level2">
<h2>Assumptions</h2>
<p>The lessons from this point onwards will assume very little apart
from the following:</p>
<ol style="list-style-type: decimal">
<li>You have access to a Unix/Linux system</li>
<li>You know how to launch a terminal program on that system</li>
<li>You have a home directory where you can create/edit new files</li>
</ol>
<p>In the following documentation, we will also assume that the logged
in user has a username ‘ubuntu’ and the home directory is located at
<code>/home/ubuntu</code>.</p>
<hr />
</div>
<div id="the-terminal-u1" class="section level2">
<h2>1. The Terminal [U1]</h2>
<p>A <em>terminal</em> is the common name for the program that does two
main things. It allows you to type input to the computer (i.e. run
programs, move/view files etc.) and it allows you to see output from
those programs. All Unix machines will have a terminal program
available.</p>
<p>Open the terminal application. You should now see something that
looks like the following:</p>
<div class="figure">
<img src="http://korflab.ucdavis.edu/Unix_and_Perl/terminal2.png"
alt="" />
<p class="caption">Terminal application</p>
</div>
<p>There will be many situations where it will be useful to have
multiple terminals open and it will be a matter of preference as to
whether you want to have multiple windows, or one window with multiple
tabs (there are typically keyboard shortcuts for switching between
windows, or moving between tabs).</p>
<hr />
</div>
<div id="your-first-unix-command-u2" class="section level2">
<h2>2. Your first Unix command [U2]</h2>
<p>It’s important to note that you will always be <em>inside</em> a
single directory when using the terminal. The default behavior is that
when you open a new terminal you start in your own <em>home</em>
directory (containing files and directories that only you can modify).
To see what files and directories are in our home directory, we need to
use the <a href="http://en.wikipedia.org/wiki/Ls">ls</a> command. This
command lists the contents of a directory. If we run the <code>ls</code>
command we should see something like:</p>
<pre class="bash"><code>ubuntu@:~$ ls
command_line_course  linux_bootcamp
ubuntu@:~$</code></pre>
<p>There are four things that you should note here:</p>
<ol style="list-style-type: decimal">
<li>You will probably see different output to what is shown here, it
depends on your computer setup. Don’t worry about that for now.</li>
<li>The <code>ubuntu@:~$</code> text that you see is the Unix <a
href="http://en.wikipedia.org/wiki/Command_line_interface">command
prompt</a>. In this case, it contains a user name (‘ubuntu’) and the
name of the current directory (‘~’, more on that later). Note that the
command prompt might not look the same on different Unix systems. In
this case, the <code>$</code> sign marks the end of the prompt.</li>
<li>The output of the <code>ls</code> command lists two things. In this
case, they are both directories, but they could also be files. We’ll
learn how to tell them apart later on. These directories were created as
part of a specific course that used this bootcamp material. You will
therefore probably see something very different on your own
computer.</li>
<li>After the <code>ls</code> command finishes it produces a new command
prompt, ready for you to type your next command.</li>
</ol>
<p>The <code>ls</code> command is used to list the contents of
<em>any</em> directory, not necessarily the one that you are currently
in. Try the following:</p>
<pre class="bash"><code>ubuntu@:~$ ls /data
bioinfo.course.data  command_line_course  galaxy  lost+found  refs

ubuntu@:~$ ls /etc/perl
CPAN  Net  XML</code></pre>
<hr />
</div>
<div id="the-unix-tree-u3" class="section level2">
<h2>3: The Unix tree [U3]</h2>
<p>Looking at directories from within a Unix terminal can often seem
confusing. But bear in mind that these directories are exactly the same
type of folders that you can see if you use any graphical file browser.
From the <em>root</em> level (<code>/</code>) there are usually a dozen
or so directories. You can treat the root directory like any other,
e.g. you can list its contents:</p>
<pre class="bash"><code>ubuntu@:~$ ls /
bin   dev   initrd.img      lib64       mnt   root  software  tmp  vmlinuz
boot  etc   initrd.img.old  lost+found  opt   run   srv       usr  vmlinuz.old
data  home  lib             media       proc  sbin  sys       var</code></pre>
<p>You might notice some of these names appearing in different colors.
Many Unix systems will display files and directories differently by
default. Other colors may be used for special types of files. When you
log in to a computer you are working with your files in your home
directory, and this is often inside a directory called ‘users’ or
‘home’.</p>
<hr />
</div>
<div id="finding-out-where-you-are-u4" class="section level2">
<h2>4: Finding out where you are [U4]</h2>
<p>There may be many hundreds of directories on any Unix machine, so how
do you know which one you are in? The command <a
href="http://en.wikipedia.org/wiki/Pwd">pwd</a> will Print the <a
href="http://en.wikipedia.org/wiki/Working_directory">Working
Directory</a> and that’s pretty much all this command does:</p>
<pre class="bash"><code>ubuntu@:~$ pwd
/home/ubuntu</code></pre>
<p>When you log in to a Unix computer, you are typically placed into
your <em>home</em> directory. In this example, after we log in, we are
placed in a directory called ‘ubuntu’ which itself is a
<em>subdirectory</em> of another directory called ‘home’. Conversely,
‘users’ is the <em>parent</em> directory of ‘clmuser’. The first forward
slash that appears in a list of directory names always refers to the top
level directory of the file system (known as the <a
href="http://en.wikipedia.org/wiki/Root_directory">root directory</a>).
The remaining forward slash (between ‘home’ and ‘ubuntu’) delimits the
various parts of the directory hierarchy. If you ever get ‘lost’ in
Unix, remember the <code>pwd</code> command.</p>
<p>As you learn Unix you will frequently type commands that don’t seem
to work. Most of the time this will be because you are in the wrong
directory, so it’s a really good habit to get used to running the
<code>pwd</code> command a lot.</p>
<hr />
</div>
<div id="making-new-directories-u5" class="section level2">
<h2>5: Making new directories [U5]</h2>
<p>If we want to make a new directory (e.g. to store some work related
data), we can use the <a
href="http://en.wikipedia.org/wiki/Tilde#Directories_and_URLs">mkdir</a>
command:</p>
<pre class="bash"><code>ubuntu@:~$ mkdir Learning_unix
ubuntu@:~$ ls
command_line_course  Learning_unix  linux_bootcamp</code></pre>
<hr />
</div>
<div id="getting-from-a-to-b-u6" class="section level2">
<h2>6: Getting from ‘A’ to ‘B’ [U6]</h2>
<p>We are in the home directory on the computer but we want to to work
in the new <code>Learning_unix</code> directory. To change directories
in Unix, we use the <a
href="http://en.wikipedia.org/wiki/Cd_(command)">cd</a> command:</p>
<pre class="bash"><code>cd Learning_unix
ubuntu@:~/Learning_unix$</code></pre>
<p>Notice that — on this system — the command prompt has expanded to
include our current directory. This doesn’t happen by default on all
Unix systems, but you should know that you can configure what
information appears as part of the command prompt.</p>
<p>Let’s make two new subdirectories and navigate into them:</p>
<pre class="bash"><code>ubuntu@:~/Learning_unix$ mkdir Outer_directory
ubuntu@:~/Learning_unix$ cd Outer_directory
ubuntu@:~/Learning_unix/Outer_directory$

ubuntu@:~/Learning_unix/Outer_directory$ mkdir Inner_directory
ubuntu@:~/Learning_unix/Outer_directory$ cd Inner_directory/
ubuntu@:~/Learning_unix/Outer_directory/Inner_directory$</code></pre>
<p>Now our command prompt is getting quite long, but it reveals that we
are three levels beneath the home directory. We created the two
directories in separate steps, but it is possible to use the
<code>mkdir</code> command in way to do this all in one step.</p>
<p>Like most Unix commands, <code>mkdir</code> supports <em>command-line
options</em> which let you alter its behavior and functionality.
Command-like options are — as the name suggests — optional arguments
that are placed after the command name. They often take the form of
single letters (following a dash). If we had used the <code>-p</code>
option of the <code>mkdir</code> command we could have done this in one
step. E.g.</p>
<pre class="bash"><code>mkdir -p Outer_directory/Inner_directory</code></pre>
<p><strong><em>Note the spaces either side the
<code>-p</code>!</em></strong></p>
<hr />
</div>
<div id="the-root-directory-u7" class="section level2">
<h2>7: The root directory [U7]</h2>
<p>Let’s change directory to the root directory, and then into our home
directory</p>
<pre class="bash"><code>ubuntu@:~/Learning_unix/Outer_directory/Inner_directory$ cd /
ubuntu@:/$ cd home
ubuntu@:/home$ cd ubuntu
ubuntu@:~$</code></pre>
<p>In this case, we may as well have just changed directory in one
go:</p>
<pre class="bash"><code>cd /home/ubuntu/</code></pre>
<p>The leading <code>/</code> is incredibly important. The following two
commands are very different:</p>
<pre class="bash"><code>cd /home/ubuntu/
cd home/ubuntu/</code></pre>
<p>The first command says go the <code>unbuntu</code> directory that is
beneath the <code>home</code> directory that is at the top level (the
root) of the file system. There can only be one
<code>/home/ubuntu</code> directory on any Unix system.</p>
<p>The second command says go to the <code>unbuntu</code> directory that
is beneath the <code>home</code> directory that is located wherever I am
right now. There can potentially be many <code>home/ubuntu</code>
directories on a Unix system (though this is unlikely).</p>
<p>Learn and understand the difference between these two commands.</p>
<hr />
</div>
<div id="navigating-upwards-in-the-unix-filesystem-u8"
class="section level2">
<h2>8: Navigating upwards in the Unix filesystem [U8]</h2>
<p>Frequently, you will find that you want to go ‘upwards’ one level in
the directory hierarchy. Two dots <code>..</code> are used in Unix to
refer to the <em>parent</em> directory of wherever you are. Every
directory has a parent except the root level of the computer. Let’s go
into the <code>Learning_unix</code> directory and then navigate up two
levels:</p>
<pre class="bash"><code>ubuntu@:~$ cd Learning_unix/
ubuntu@:~/Learning_unix$ cd ..
ubuntu@:~$ cd ..
ubuntu@:/home$</code></pre>
<p>What if you wanted to navigate up <em>two</em> levels in the file
system in one go? It’s very simple, just use two sets of the
<code>..</code> operator, separated by a forward slash:</p>
<pre class="bash"><code>cd ../..</code></pre>
<hr />
</div>
<div id="absolute-and-relative-paths" class="section level2">
<h2>9: Absolute and relative paths</h2>
<p>Using <code>cd ..</code> allows us to change directory
<em>relative</em> to where we are now. You can also always change to a
directory based on its <em>absolute</em> location. E.g. if you are
working in the <code>/home/ubuntu/Learning_unix</code> directory and you
then want to change to the <code>/tmp</code> directory, then you could
do either of the following:</p>
<pre><code>$ cd ../../../tmp</code></pre>
<p>or…</p>
<pre><code>$ cd /tmp</code></pre>
<p>They both achieve the same thing, but the 2nd example requires that
you know about the full <em>path</em> from the root level of the
computer to your directory of interest (the ‘path’ is an important
concept in Unix). Sometimes it is quicker to change directories using
the relative path, and other times it will be quicker to use the
absolute path.</p>
<hr />
</div>
<div id="finding-your-way-back-home-u10" class="section level2">
<h2>10: Finding your way back home [U10]</h2>
<p>Remember that the command prompt shows you the name of the directory
that you are currently in, and that when you are in your home directory
it shows you a tilde character (`~``) instead? This is because Unix uses
the tilde character as a short-hand way of <a
href="http://en.wikipedia.org/wiki/Tilde#Directories_and_URLs">specifying
a home directory</a>.</p>
<p>See what happens when you try the following commands (use the
<code>pwd</code> command after each one to confirm the results if
necessary):</p>
<pre class="bash"><code>cd / 
cd ~ 
cd</code></pre>
<p>Hopefully, you should find that <code>cd</code> and <code>cd ~</code>
do the same thing, i.e. they take you back to your home directory (from
wherever you were). You will frequently want to jump straight back to
your home directory, and typing <code>cd</code> is a very quick way to
get there.</p>
<p>You can also use the <code>~</code> as a quick way of navigating into
subdirectories of your home directory when your current directory is
somewhere else. I.e. the quickest way of navigating from the root
directory to your <code>Learning_unix</code> directory is as
follows:</p>
<pre class="bash"><code>ubuntu@:~$ cd /
ubuntu@:/$ cd ~/Learning_unix</code></pre>
<hr />
<p>##11: Making the <code>ls</code> command more useful [U11] ##</p>
<p>The <code>..</code> operator that we saw earlier can also be used
with the <code>ls</code> command, e.g. you can list directories that are
‘above’ you:</p>
<pre class="bash"><code>ubuntu@:~/Learning_unix$ cd ~/Learning_unix/Outer_directory/
ubuntu@:~/Learning_unix/Outer_directory$ ls ../../
command_line_course  Learning_unix  linux_bootcamp</code></pre>
<p>Time to learn another useful command-line option. If you add the
letter ‘l’ to the <code>ls</code> command it will give you a longer
output compared to the default:</p>
<pre class="bash"><code>ubuntu@:~/Learning_unix$ ls -l /home
total 12
drwxr-xr-x 8 galaxy galaxy 4096 Apr  2 22:47 galaxy
drwxr-xr-x 3 root   root   4096 Mar 16 23:06 nate
drwxr-xr-x 9 ubuntu ubuntu 4096 Jun 15 02:07 ubuntu</code></pre>
<p>For each file or directory we now see more information (including
file ownership and modification times). The ‘d’ at the start of each
line indicates that these are directories. There are many, many
different options for the <code>ls</code> command. Try out the following
(against any directory of your choice) to see how the output
changes.</p>
<pre class="bash"><code>ls -l 
ls -R 
ls -l -t -r 
ls -lh</code></pre>
<p>Note that the last example combine multiple options but only use one
dash. This is a very common way of specifying multiple command-line
options. You may be wondering what some of these options are doing. It’s
time to learn about Unix documentation….</p>
<hr />
</div>
<div id="man-pages-u12" class="section level2">
<h2>12: Man pages [U12]</h2>
<p>If every Unix command has so many options, you might be wondering how
you find out what they are and what they do. Well, thankfully every Unix
command has an associated ‘manual’ that you can access by using the
<code>man</code> command. E.g.</p>
<pre class="bash"><code>man ls 
man cd
man man # yes even the man command has a manual page</code></pre>
<p>When you are using the man command, press <code>space</code> to
scroll down a page, <code>b</code> to go back a page, or <code>q</code>
to quit. You can also use the up and down arrows to scroll a line at a
time. The man command is actually using another Unix program, a text
viewer called <code>less</code>, which we’ll come to later on.</p>
<hr />
</div>
<div id="removing-directories-u13" class="section level2">
<h2>13: Removing directories [U13]</h2>
<p>We now have a few (empty) directories that we should remove. To do
this use the <a href="http://en.wikipedia.org/wiki/Rmdir">rmdir</a>
command, this will only remove empty directories so it is quite safe to
use. If you want to know more about this command (or any Unix command),
then remember that you can just look at its man page.</p>
<pre class="bash"><code>ubuntu@:~$ cd ~/Learning_unix/Outer_directory/
ubuntu@:~/Learning_unix/Outer_directory$ rmdir Inner_directory/
ubuntu@:~/Learning_unix/Outer_directory$ cd ..
ubuntu@:~/Learning_unix$ rmdir Outer_directory/
ubuntu@:~/Learning_unix$ ls
ubuntu@:~/Learning_unix$</code></pre>
<p>*** Note, you have to be outside a directory before you can remove it
with <code>rmdir</code> ***</p>
<hr />
</div>
<div id="using-tab-completion-u14" class="section level2">
<h2>14: Using tab completion [U14]</h2>
<p>Saving keystrokes may not seem important, but the longer that you
spend typing in a terminal window, the happier you will be if you can
reduce the time you spend at the keyboard. Especially, as prolonged
typing is not good for your body. So the best Unix tip to learn early on
is that you can <a
href="http://en.wikipedia.org/wiki/Command_line_completion">tab
complete</a> the names of files and programs on most Unix systems. Type
enough letters that uniquely identify the name of a file, directory or
program and press tab…Unix will do the rest. E.g. if you type ‘tou’ and
then press tab, Unix should autocomplete the word to ‘touch’ (this is a
command which we will learn more about in a minute). In this case, tab
completion will occur because there are no other Unix commands that
start with ‘tou’. If pressing tab doesn’t do anything, then you have not
have typed enough unique characters. In this case pressing tab
<em>twice</em> will show you all possible completions. This trick can
save you a LOT of typing!</p>
<p>Navigate to your home directory, and then use the <code>cd</code>
command to change to the <code>Learning_unix</code> directory. Use tab
completion to complete directory name. If there are no other directories
starting with ‘L’ in your home directory, then you should only need to
type ‘cd’ + ‘L’ + ‘tab’.</p>
<blockquote>
<p><strong><em>Tab completion will make your life easier and make you
more productive!</em></strong></p>
</blockquote>
<p>Another great time-saver is that Unix stores a list of all the
commands that you have typed in each login session. You can access this
list by using the <a
href="http://en.wikipedia.org/wiki/History_(Unix)">history</a> command
or more simply by using the up and down arrows to access anything from
your history. So if you type a long command but make a mistake, press
the up arrow and then you can use the left and right arrows to move the
cursor in order to make a change.</p>
<hr />
</div>
<div id="creating-empty-files-with-the-touch-command-u15"
class="section level2">
<h2>15: Creating empty files with the touch command [U15]</h2>
<p>The following sections will deal with Unix commands that help us to
work with files, i.e. copy files to/from places, move files, rename
files, remove files, and most importantly, look at files. First, we need
to have some files to play with. The Unix command <a
href="http://en.wikipedia.org/wiki/Command_line_completion">touch</a>
will let us create a new, empty file. The touch command does other
things too, but for now we just want a couple of files to work with.</p>
<pre class="bash"><code>ubuntu@:~$ cd Learning_unix/
ubuntu@:~/Learning_unix$ touch heaven.txt
ubuntu@:~/Learning_unix$ touch earth.txt
ubuntu@:~/Learning_unix$ ls
earth.txt  heaven.txt</code></pre>
<hr />
</div>
<div id="moving-files-u16" class="section level2">
<h2>16: Moving files [U16]</h2>
<p>Now, let’s assume that we want to move these files to a new directory
(‘Temp’). We will do this using the Unix <a
href="http://en.wikipedia.org/wiki/Mv">mv</a> (move) command. Remember
to use tab completion:</p>
<pre class="bash"><code>ubuntu@:~/Learning_unix$ mkdir Temp
ubuntu@:~/Learning_unix$ mv heaven.txt Temp/
ubuntu@:~/Learning_unix$ mv earth.txt Temp/
ubuntu@:~/Learning_unix$ ls
Temp
ubuntu@:~/Learning_unix$ ls Temp/
earth.txt  heaven.txt</code></pre>
<p>For the <code>mv</code> command, we always have to specify a source
file (or directory) that we want to move, and then specify a target
location. If we had wanted to we could have moved both files in one go
by typing any of the following commands:</p>
<pre class="bash"><code>mv *.txt Temp/ 
mv *t Temp/ 
mv *ea* Temp/</code></pre>
<p>The asterisk <code>*</code> acts as a <a
href="http://en.wikipedia.org/wiki/Wildcard_character">wild-card
character</a>, essentially meaning ‘match anything’. The second example
works because there are no other files or directories in the directory
that end with the letters ‘t’ (if there was, then they would be moved
too). Likewise, the third example works because only those two files
contain the letters ‘ea’ in their names. Using wild-card characters can
save you a lot of typing.</p>
<p>The ‘?’ character is also a wild-card but with a slightly different
meaning. See if you can work out what it does.</p>
<hr />
</div>
<div id="renaming-files-u17" class="section level2">
<h2>17: Renaming files [U17]</h2>
<p>In the earlier example, the destination for the <code>mv</code>
command was a directory name (Temp). So we moved a file from its source
location to a target location, but note that the target could have also
been a (different) file name, rather than a directory. E.g. let’s make a
new file and move it whilst renaming it at the same time:</p>
<pre class="bash"><code>ubuntu@:~/Learning_unix$ touch rags
ubuntu@:~/Learning_unix$ ls
rags  Temp
ubuntu@:~/Learning_unix$ mv rags Temp/riches
ubuntu@:~/Learning_unix$ ls Temp/
earth.txt  heaven.txt  riches</code></pre>
<p>In this example we create a new file (‘rags’) and move it to a new
location and in the process change the name (to ‘riches’). So
<code>mv</code> can rename a file as well as move it. The logical
extension of this is using <code>mv</code> to rename a file without
moving it (you have to use <code>mv</code> to do this as Unix does not
have a separate ‘rename’ command):</p>
<pre class="bash"><code>ubuntu@:~/Learning_unix$ mv Temp/riches Temp/rags</code></pre>
<hr />
</div>
<div id="moving-directories-u18" class="section level2">
<h2>18: Moving directories [U18]</h2>
<p>It is important to understand that as long as you have specified a
‘source’ and a ‘target’ location when you are moving a file, then it
doesn’t matter what your <em>current</em> directory is. You can move or
copy things within the same directory or between different directories
regardless of whether you are in any of those directories. Moving
directories is just like moving files:</p>
<pre class="bash"><code>ubuntu@:~/Learning_unix$ mv Temp/riches Temp/rags
ubuntu@:~/Learning_unix$ mkdir Temp2
ubuntu@:~/Learning_unix$ mv Temp2 Temp
ubuntu@:~/Learning_unix$ ls Temp/
earth.txt  heaven.txt  rags  Temp2</code></pre>
<p>This step moves the Temp2 directory inside the Temp directory. Try
creating a ‘Temp3’ directory inside ‘Learning_unix’ and then
<code>cd</code> to <code>/tmp</code>. Can you move <code>Temp3</code>
inside <code>Temp</code> without changing directory?</p>
<hr />
</div>
<div id="removing-files-u19" class="section level2">
<h2>19: Removing files [U19]</h2>
<p>You’ve seen how to remove a directory with the <code>rmdir</code>
command, but <code>rmdir</code> won’t remove directories if they contain
any files. So how can we remove the files we have created (inside
<code>Learning_Unix/Temp</code>)? In order to do this, we will have to
use the <a href="http://en.wikipedia.org/wiki/Rm_(Unix)">rm</a> (remove)
command.</p>
<blockquote>
<p><strong><em>Please read the next section VERY carefully. Misuse of
the <code>rm</code> command can lead to needless death &amp;
destruction</em></strong></p>
</blockquote>
<p>Potentially, <code>rm</code> is a very dangerous command; if you
delete something with <code>rm</code>, you will not get it back! It is
possible to delete everything in your home directory (all directories
and subdirectories) with <code>rm</code>, that is why it is such a
dangerous command.</p>
<p>Let me repeat that last part again. It is possible to delete EVERY
file you have ever created with the <code>rm</code> command. Are you
scared yet? You should be. Luckily there is a way of making
<code>rm</code> a little bit safer. We can use it with the
<code>-i</code> command-line option which will ask for confirmation
before deleting anything (remember to use tab-completion):</p>
<pre class="bash"><code>ubuntu@:~/Learning_unix$ cd Temp
ubuntu@:~/Learning_unix/Temp$ ls
earth.txt  heaven.txt  rags  Temp2
ubuntu@:~/Learning_unix/Temp$ rm -i earth.txt heaven.txt rags
rm: remove regular empty file ‘earth.txt’? y
rm: remove regular empty file ‘heaven.txt’? y
rm: remove regular empty file ‘rags’? y
ubuntu@:~/Learning_unix/Temp$ ls
Temp2</code></pre>
<p>We could have simplified this step by using a wild-card
(e.g. <code>rm -i *.txt</code>) or we could have made things more
complex by removing each file with a separate <code>rm</code> command.
Let’s finish cleaning up:</p>
<pre class="bash"><code>rmdir Temp2/Temp3
rmdir Temp2
cd ..
rmdir Temp</code></pre>
<hr />
</div>
<div id="copying-files-u20" class="section level2">
<h2>20: Copying files [U20]</h2>
<p>Copying files with the <a
href="http://en.wikipedia.org/wiki/Cp_(Unix)">cp</a> (copy) command is
very similar to moving them. Remember to always specify a source and a
target location. Let’s create a new file and make a copy of it:</p>
<pre class="bash"><code>ubuntu@:~/Learning_unix$ touch file1
ubuntu@:~/Learning_unix$ cp file1 file2
ubuntu@:~/Learning_unix$ ls
file1  file2</code></pre>
<p>What if we wanted to copy files from a different directory to our
current directory? Let’s put a file in our home directory (specified by
<code>~</code> remember) and copy it to the current directory
(<code>Learning_unix</code>):</p>
<pre class="bash"><code>ubuntu@:~/Learning_unix$ touch ~/file3
ubuntu@:~/Learning_unix$ ls ~
command_line_course  file3  Learning_unix  linux_bootcamp
ubuntu@:~/Learning_unix$ cp ~/file3 .
ubuntu@:~/Learning_unix$ ls
file1  file2  file3</code></pre>
<p>This last step introduces another new concept. In Unix, the current
directory can be represented by a <code>.</code> (dot) character. You
will mostly use this only for copying files to the current directory
that you are in. Compare the following:</p>
<pre class="bash"><code>ls 
ls . 
ls ./</code></pre>
<p>In this case, using the dot is somewhat pointless because
<code>ls</code> will already list the contents of the current directory
by default. Also note how the trailing slash is optional. You can use
<code>rm</code> to remove the temporary files.</p>
<hr />
</div>
<div id="copying-directories-u21" class="section level2">
<h2>21: Copying directories [U21]</h2>
<p>The <code>cp</code> command also allows us (with the use of a
command-line option) to copy entire directories. Use <code>man cp</code>
to see how the <code>-R</code> or <code>-r</code> options let you copy a
directory <em>recursively</em>.</p>
<hr />
</div>
<div id="viewing-files-with-less-u22" class="section level2">
<h2>22: Viewing files with less [U22]</h2>
<p>So far we have covered listing the contents of directories and
moving/copying/deleting either files and/or directories. Now we will
quickly cover how you can look at files. The <a
href="http://en.wikipedia.org/wiki/Less_(Unix)">less</a> command lets
you view (but not edit) text files. We will use the <a
href="http://en.wikipedia.org/wiki/Echo_(command)">echo</a> command to
put some text in a file and then view it:</p>
<pre class="bash"><code>ubuntu@:~/Learning_unix$ echo &quot;Call me Ishmael.&quot;
Call me Ishmael.
ubuntu@:~/Learning_unix$ echo &quot;Call me Ishmael.&quot; &gt; opening_lines.txt
ubuntu@:~/Learning_unix$ ls
opening_lines.txt
ubuntu@:~/Learning_unix$ less opening_lines.txt</code></pre>
<p>On its own, <code>echo</code> isn’t a very exciting Unix command. It
just echoes text back to the screen. But we can redirect that text into
an output file by using the <code>&gt;</code> symbol. This allows for
something called file <a
href="http://en.wikipedia.org/wiki/Redirection_(Unix)">redirection</a>.</p>
<blockquote>
<p><strong><em>Careful when using file redirection (&gt;), it will
overwrite any existing file of the same name</em></strong></p>
</blockquote>
<p>When you are using less, you can bring up a page of help commands by
pressing <code>h</code>, scroll forward a page by pressing
<code>space</code>, or go forward or backwards one line at a time by
pressing <code>j</code> or <code>k</code>. To exit less, press
<code>q</code> (for quit). The <code>less</code> program also does about
a million other useful things (including text searching).</p>
<hr />
</div>
<div id="viewing-files-with-cat-u23" class="section level2">
<h2>23: Viewing files with cat [U23]</h2>
<p>Let’s add another line to the file:</p>
<pre class="bash"><code>ubuntu@:~/Learning_unix$ echo &quot;The primroses were over.&quot; &gt;&gt; opening_lines.txt
ubuntu@:~/Learning_unix$ cat opening_lines.txt
Call me Ishmael.
The primroses were over.</code></pre>
<p>Notice that we use <code>&gt;&gt;</code> and not just
<code>&gt;</code>. This operator will <strong>append</strong> to a file.
If we only used <code>&gt;</code>, we would end up overwriting the file.
The <a href="http://en.wikipedia.org/wiki/Cat_(Unix)">cat</a> command
displays the contents of the file (or files) and then returns you to the
command line. Unlike <code>less</code> you have no control on how you
view that text (or what you do with it). It is a very simple, but
sometimes useful, command. You can use <code>cat</code> to quickly
combine multiple files or, if you wanted to, make a copy of an existing
file:</p>
<pre class="bash"><code>cat opening_lines.txt &gt; file_copy.txt</code></pre>
<hr />
</div>
<div id="counting-characters-in-a-file-u24" class="section level2">
<h2>24: Counting characters in a file [U24]</h2>
<pre class="bash"><code>ubuntu@:~/Learning_unix$ ls
opening_lines.txt

ubuntu@:~/Learning_unix$ ls -l
total 4
-rw-rw-r-- 1 ubuntu ubuntu 42 Jun 15 04:13 opening_lines.txt

ubuntu@:~/Learning_unix$ wc opening_lines.txt
 2  7 42 opening_lines.txt

ubuntu@:~/Learning_unix$ wc -l opening_lines.txt
2 opening_lines.txt</code></pre>
<p>The <code>ls -l</code> option shows us a long listing, which includes
the size of the file in bytes (in this case ‘42’). Another way of
finding this out is by using Unix’s <a
href="https://en.wikipedia.org/wiki/Wc_(Unix)">wc</a> command (word
count). By default this tells you many lines, words, and characters are
in a specified file (or files), but you can use command-line options to
give you just one of those statistics (in this case we count lines with
<code>wc -l</code>).</p>
<hr />
</div>
<div id="editing-small-text-files-with-nano-u25" class="section level2">
<h2>25: Editing small text files with nano [U25]</h2>
<p>Nano is a lightweight editor installed on most Unix systems. There
are many more powerful editors (such as ‘emacs’ and ‘vi’), but these
have steep learning curves. Nano is very simple. You can edit (or
create) files by typing:</p>
<pre class="bash"><code>nano opening_lines.txt</code></pre>
<p>You should see the following appear in your terminal:</p>
<p><img src="http://korflab.ucdavis.edu/Unix_and_Perl/nano2.png" /></p>
<p>The bottom of the nano window shows you a list of simple commands
which are all accessible by typing ‘Control’ plus a letter. E.g. Control
+ X exits the program.</p>
<hr />
</div>
<div id="the-path-environment-variable-u26" class="section level2">
<h2>26: The $PATH environment variable [U26]</h2>
<p>One other use of the <code>echo</code> command is for displaying the
contents of something known as <em>environment variables</em>. These
contain user-specific or system-wide values that either reflect simple
pieces of information (your username), or lists of useful locations on
the file system. Some examples:</p>
<pre class="bash"><code>ubuntu@:~/Learning_unix$ echo $USER
ubuntu
ubuntu@:~/Learning_unix$ echo $HOME
/home/ubuntu
ubuntu@:~/Learning_unix$ echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games</code></pre>
<p>The last one shows the content of the <code>$PATH</code> environment
variable, which displays a — colon separated — list of directories that
are expected to contain programs that you can run. This includes all of
the Unix commands that you have seen so far. These are files that live
in directories which are run like programs (e.g. <code>ls</code> is just
a special type of file in the <code>/bin</code> directory).</p>
<p>Knowing how to change your $PATH to include custom directories can be
necessary sometimes (e.g. if you install some new bioinformatics
software in a non-standard location).</p>
<hr />
</div>
<div id="matching-lines-in-files-with-grep-u27" class="section level2">
<h2>27: Matching lines in files with grep [U27]</h2>
<p>Use <code>nano</code> to add the following lines to
<code>opening_lines.txt</code>:</p>
<pre><code>Now is the winter of our discontent.
All children, except one, grow up.
The Galactic Empire was dying.
In a hole in the ground there lived a hobbit.
It was a pleasure to burn.
It was a bright, cold day in April, and the clocks were striking thirteen.
It was love at first sight.
I am an invisible man.
It was the day my grandmother exploded.
When he was nearly thirteen, my brother Jem got his arm badly broken at the elbow.
Marley was dead, to begin with.</code></pre>
<p>You will often want to search files to find lines that match a
certain pattern. The Unix command <a
href="http://en.wikipedia.org/wiki/Grep">grep</a> does this (and much
more). The following examples show how you can use grep’s command-line
options to:</p>
<ul>
<li>show lines that match a specified pattern</li>
<li>ignore case when matching (<code>-i</code>)</li>
<li>only match whole words (<code>-w</code>)</li>
<li>show lines that don’t match a pattern (<code>-v</code>)</li>
<li>Use wildcard characters and other patterns to allow for alternatives
(<code>*</code>, <code>.</code>, and <code>[]</code>)</li>
</ul>
<pre class="bash"><code>grep was opening_lines.txt
The Galactic Empire was dying.
It was a pleasure to burn.
It was a bright, cold day in April, and the clocks were striking thirteen.
It was love at first sight.
It was the day my grandmother exploded.
When he was nearly thirteen, my brother Jem got his arm badly broken at the elbow.
Marley was dead, to begin with.

grep -v was opening_lines.txt
Call me Ishmael.
The primroses were over.
Now is the winter of our discontent.
All children, except one, grow up.
In a hole in the ground there lived a hobbit.
I am an invisible man.

grep all opening_lines.txt
Call me Ishmael.

grep -i all opening_lines.txt
Call me Ishmael.
All children, except one, grow up.

grep in opening_lines.txt
Now is the winter of our discontent.
The Galactic Empire was dying.
In a hole in the ground there lived a hobbit.
It was a bright, cold day in April, and the clocks were striking thirteen.
I am an invisible man.
Marley was dead, to begin with.

grep -w in opening_lines.txt
In a hole in the ground there lived a hobbit.
It was a bright, cold day in April, and the clocks were striking thirteen.

grep -w o.. opening_lines.txt
Now is the winter of our discontent.
All children, except one, grow up.

grep [aeiou]t opening_lines.txt
In a hole in the ground there lived a hobbit.
It was love at first sight.
It was the day my grandmother exploded.
When he was nearly thirteen, my brother Jem got his arm badly broken at the elbow.
Marley was dead, to begin with.

grep -w -i [aeiou]t opening_lines.txt
It was a pleasure to burn.
It was a bright, cold day in April, and the clocks were striking thirteen.
It was love at first sight.
It was the day my grandmother exploded.
When he was nearly thirteen, my brother Jem got his arm badly broken at the elbow.</code></pre>
<hr />
</div>
<div id="combining-unix-commands-with-pipes-u28" class="section level2">
<h2>28: Combining Unix commands with pipes [U28]</h2>
<p>One of the most poweful features of Unix is that you can send the
output from one command or program to any other command (as long as the
second commmand accepts input of some sort). We do this by using what is
known as a <a href="http://en.wikipedia.org/wiki/Pipe_(Unix)">pipe</a>.
This is implemented using the ‘|’ character (which is a character which
always seems to be on different keys depending on the keyboard that you
are using). Think of the pipe as simply connecting two Unix programs.
Here’s an example which introduces some new Unix commands:</p>
<pre class="bash"><code>ubuntu@:~/Learning_unix$ grep was opening_lines.txt | wc -c
316

ubuntu@:~/Learning_unix$
grep was opening_lines.txt | sort | head -n 3 | wc -c
130</code></pre>
<p>The first use of <code>grep</code> searches the specified file for
lines matching ‘was’, it sends the lines that match through a pipe to
the <code>wc</code> program. We use the <code>-c</code> option to just
count characters in the matching lines (316).</p>
<p>The second example first sends the output of <code>grep</code> to the
Unix <code>sort</code> command. This sorts a file alphanumerically by
default. The sorted output is sent to the <code>head</code> command
which by default shows the first 10 lines of a file. We use the
<code>-n</code> option of this command to only show 3 lines. These 3
lines are then sent to the <code>wc</code> command as before.</p>
<blockquote>
<p><strong><em>Whenever making a long pipe, test each step as you build
it!</em></strong></p>
</blockquote>
<hr />
</div>
</div>
<div id="miscellaneous-unix-power-commands" class="section level1">
<h1>Miscellaneous Unix power commands</h1>
<p>The following examples introduce some other Unix commands, and show
how they could be used to work on a fictional file called
<code>file.txt</code>. Remember, you can always learn more about these
Unix commands from their respective man pages with the <code>man</code>
command. These are not all real world cases, but rather show the
diversity of Unix command-line tools:</p>
<ul>
<li>View the penultimate 10 lines of a file (using <a
href="http://en.wikipedia.org/wiki/Head_(Unix)">head</a> and <a
href="http://en.wikipedia.org/wiki/Tail_(Unix)">tail</a> commands):</li>
</ul>
<pre class="bash"><code>tail -n 20 file.txt | head</code></pre>
<ul>
<li>Show lines of a file that begin with a start codon (ATG) (the
<code>^</code> matches patterns at the start of a line):</li>
</ul>
<pre class="bash"><code>grep &quot;^ATG&quot; file.txt</code></pre>
<ul>
<li>Cut out the 3rd column of a tab-delimited text file and sort it to
only show unique lines (i.e. remove duplicates):</li>
</ul>
<pre class="bash"><code>cut -f 3 file.txt | sort -u</code></pre>
<ul>
<li>Count how many lines in a file contain the words ‘cat’ or ‘bat’
(<code>-c</code> option of <code>grep</code> counts lines):</li>
</ul>
<pre class="bash"><code>grep -c &#39;[bc]at&#39; file.txt</code></pre>
<ul>
<li>Turn lower-case text into upper-case (using <a
href="http://en.wikipedia.org/wiki/Tr_(Unix)">tr</a> command to
‘transliterate’):</li>
</ul>
<pre class="bash"><code>cat file.txt | tr &#39;a-z&#39; &#39;A-Z&#39;</code></pre>
<ul>
<li>Change all occurences of ‘Chr1’ to ‘Chromosome 1’ and write changed
output to a new file (using <a
href="http://en.wikipedia.org/wiki/Sed">sed</a> command):</li>
</ul>
<pre class="bash"><code>cat file.txt | sed &#39;s/Chr1/Chromosome 1/&#39; &gt; file2.txt</code></pre>
</div>




</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
